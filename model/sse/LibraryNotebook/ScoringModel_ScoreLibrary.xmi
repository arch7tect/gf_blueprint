<?xml version="1.0" encoding="ASCII"?>
<sse:LibraryNotebook xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:sse="http://www.neoflex.ru/meta/sse" name="ScoringModel_ScoreLibrary" shortName="ScoreLibrary" description="functions for score card development">
  <auditInfo changeUser="orlov" changeDateTime="2019-07-12T11:14:20.533+0300" createUser="asidorov" createDateTime="2019-06-18T18:51:35.808+0300"/>
  <paragraphs name="ScoringModel_ScoreLibrary_2019-06-18T18:52:52.014" title="Data Transform Functions" textVisible="true" resultVisible="true" titleVisible="true">
    <body xsi:type="sse:CodeBody" interpreter="R" text="### ---- II. Functions for Analysis ----------------&#xA;##### ---- 1. Data Transformation Functions --------&#xA;&#xA;MonthlyRollRates &lt;- function(data, initState, finalState, sectorLabels, legend = TRUE){&#xA;  #&#xA;  # returns monthly roll rates PD: iS-> fS withtin certain sectors&#xA;  # finalState in a Default state&#xA;  # sectorLabels might be a states vector&#xA;  # &#xA;  if (finalState &lt;= initState) {&#xA;    stop(&quot;initState should be less finalState&quot;)&#xA;  }&#xA;  if (data[SectorLabel %in% sectorLabels, .N] == 0){&#xA;    stop(paste(sectorLabels,&quot; contains no contracts&quot;))&#xA;  }&#xA;  periodSeq &lt;- data[SectorLabel %in% sectorLabels, NA, by = Period]&#xA;&#xA;  portfolioState &lt;- &#xA;    data[SectorLabel %in% sectorLabels][&#xA;      Rating == initState, .N, by = Period][&#xA;      periodSeq, .(Period,  cnt = x.N), on = .(Period)][order(Period)]&#xA;&#xA;  transOverStatesNum &lt;- finalState - initState&#xA;  portfolioTransit &lt;-&#xA;    data[SectorLabel %in% sectorLabels][, &#xA;      PeriodFrwd := shift(Rating, n = transOverStatesNum, type = 'lead'), by = loanid][&#xA;      Rating == initState &amp; PeriodFrwd == finalState, .N, by = Period][&#xA;      periodSeq, .(Period,  cnt = x.N), on = .(Period)][order(Period)]&#xA;  portfolioTransit[, cnt := ifelse(is.na(cnt), 0, cnt)]&#xA;  res.dt &lt;- &#xA;    portfolioTransit[portfolioState, ':='(PD = x.cnt / ifelse(is.na(i.cnt), 1, i.cnt),&#xA;                                          Universe = ifelse(is.na(i.cnt), 0, i.cnt)), &#xA;                     on = .(Period)]&#xA;&#xA;  # shift rates from the period of Universe to the period when the default occurs&#xA;  # currently Period is the period when Universe is calculated,&#xA;  # we need Period be the period of default&#xA;  res.dt[, ':='(cnt = shift(cnt, n = transOverStatesNum, type = 'lag'),&#xA;                PD = shift(PD, n = transOverStatesNum, type = 'lag'),&#xA;                Universe = shift(Universe, n = transOverStatesNum, type = 'lag'))]&#xA;  if(legend){&#xA;    res.dt[, ':='(rateType = paste0('PD',initState,'_',finalState),&#xA;                  sector = paste(sectorLabels, collapse = ','))]&#xA;  }&#xA;  rm(periodSeq, portfolioState, portfolioTransit)&#xA;  return(res.dt)&#xA;} &#xA;plotRollRates &lt;- function(sectorLabel, data, xbreaks = &quot;6 months&quot;,    #TODO: update these from &quot;MacroAdjustment.R&quot; -- Functions imported from Malta project&#xA;                          addSmoothing = FALSE, span = 0.5, gg.aspect.ratio = NA){&#xA;  plt &lt;- &#xA;    ggplot(data[sector == sectorLabel],&#xA;           aes(x = Period, y = PD * 100, color = rateType)) + &#xA;    geom_line() +&#xA;    scale_x_date(date_breaks = xbreaks, date_labels = &quot;%Y-%m&quot;) +&#xA;    scale_color_manual(values = c('chartreuse4', 'firebrick','navy')) + &#xA;    ylab(&quot;ODR, %&quot;) + xlab(paste(&quot;sector&quot;,sectorLabel)) + &#xA;    facet_grid(rateType ~ ., scales = &quot;free&quot;) +&#xA;    theme(axis.text.x = element_text(angle = 90, hjust = 1))&#xA;  if(addSmoothing) &#xA;    plt &lt;- plt + geom_smooth(span = span)&#xA;  if(!is.na(gg.aspect.ratio))&#xA;    plt &lt;- plt + theme(aspect.ratio = gg.aspect.ratio)&#xA;  print(plt)&#xA;}&#xA;&#xA;&#xA;exportCumulativePDs &lt;- function(data, fileName, CreditRiskScenario = &quot;&quot;, append = FALSE){&#xA;  # export Cumulative PDs in long format (as in Fusion Risk)&#xA;  if (!'periodNum' %in% colnames(data))&#xA;    stop('data should contain period numbers and PDs in columns')&#xA;  PDrefDict = c('PD0_9' = 'PD0_9', 'PD1_9' = 'PD1_9', 'PD2_9' = 'PD2_9','PD3_9' = 'PD3_9', 'PD4_9' = 'PD4_9')&#xA;  result &lt;- melt(data, id.vars = 'periodNum', variable.factor = FALSE)&#xA;  result[, ':='(sector = sapply(strsplit(variable, split = '[.]'), `[`, 1),&#xA;                PDref = sapply(strsplit(variable, split = '[.]'), `[`, 2))]&#xA;  write.table(result[order(sector, PDref, periodNum)][, &#xA;                                                      .(CreditRiskScenario = CreditRiskScenario, &#xA;                                                        PartySector = sector, &#xA;                                                        PDReference = PDrefDict[PDref], &#xA;                                                        ObservationDate = format(today(), '%d/%m/%Y'),&#xA;                                                        RateMaturity = paste0(periodNum,'m'), &#xA;                                                        HistoryValue = value * 100)], &#xA;              sep = &quot;\t&quot;, dec = &quot;.&quot;,&#xA;              file = fileName, quote = FALSE, row.names = FALSE, append = append, col.names = !append)&#xA;}&#xA;#TODO: exportCumulativePDsFusionRisk - export Cumulative PD in a fusion risk format&#xA;&#xA;##### ------- 2. Observed Default Rates (ODRs) Functions ------------&#xA;&#xA;# I. Clean up the portfolio matrix:&#xA;# 1.Filter contracts and shift rations with a desired initial State (rating)&#xA;initStatePortfolio &lt;- function(portfolio, initState, curInitState = 0){&#xA;  require(matrixStats)&#xA;  # makes a new porfolio which starts with an initState (rather than with state 1)&#xA;&#xA;  if (initState &lt; curInitState)&#xA;    stop('initState must be more specific than curInitState')&#xA;  &#xA;  # select loans which had been in initState and get min period when it had gone there&#xA;  initStatesInPort &lt;- which(portfolio == initState, arr.ind = TRUE) &#xA;  # initStatesInPort is a matrix [row, col] with all initStates&#xA;  # find the first period in initState by each loan (i.e. row):&#xA;  if (nrow(initStatesInPort) > 0){&#xA;    minInitStates &lt;- aggregate(initStatesInPort[,'col'], by=list(initStatesInPort[,'row']), FUN = min)&#xA;  } else { &#xA;    # not such initStates in the portfolio, return NA:&#xA;    return(as.matrix(NA))&#xA;  }&#xA;  names(minInitStates) &lt;- c('row', 'colInitState')&#xA;  maxColNum &lt;- ncol(portfolio)&#xA;  &#xA;  resPortfolio &lt;- &#xA;    mapply(FUN = function(row, colInitState, colNum){&#xA;      if(colInitState > colNum) stop('colInitState must be less colNum')&#xA;      res &lt;- portfolio[row, colInitState:colNum]&#xA;      res &lt;- c(res, rep(NA, colInitState - 1)) # stuff tail with NAs&#xA;      return(res) &#xA;    }, minInitStates$row, minInitStates$colInitState, colNum = maxColNum, SIMPLIFY = F)&#xA;  resPortfolio &lt;- do.call(rbind, resPortfolio)&#xA;  if(!is.matrix(resPortfolio)) { &#xA;    # if one-contract on NULL portfolio is left&#xA;    resPortfolio &lt;- matrix(resPortfolio, nrow = 1)&#xA;  }&#xA;  # drop columns with all NAs:&#xA;  # calculate Num of NA, P, D in each column:&#xA;  colStatusesCount &lt;- &#xA;    colCounts(resPortfolio, value = NA, na.rm = F) +&#xA;    colCounts(resPortfolio, value = -1, na.rm = T) +&#xA;    colCounts(resPortfolio, value =  9, na.rm = T) &#xA;&#xA;  # just leave one extra column&#xA;  maxRelevantColIdx &lt;- max(which(colStatusesCount &lt; nrow(resPortfolio)))&#xA;  if(maxRelevantColIdx &lt; ncol(resPortfolio)) &#xA;    maxRelevantColIdx &lt;- maxRelevantColIdx + 1&#xA;  if(maxRelevantColIdx &lt; 1)  # corner case e.g. if all are in 9 (Default)&#xA;    maxRelevantColIdx &lt;- 1&#xA;  resPortfolio &lt;- resPortfolio[, 1:maxRelevantColIdx, drop = FALSE] &#xA;  return(resPortfolio)&#xA;}&#xA;# 2. Fill in gaps in ratings between subsequent months &#xA;#    with LOCF (Last Observation Carried Forward) &#xA;fillInGaps &lt;- function(portfolio){&#xA;  resPortfolio &lt;- &#xA;    apply(portfolio, MARGIN = 1, FUN = function(r){&#xA;      # take the range where Status available&#xA;      if(length(which(!is.na(r))) == 0) {&#xA;        return(r)&#xA;      }&#xA;      minStatusCol = min(which(!is.na(r)))&#xA;      maxStatusCol = max(which(!is.na(r)))&#xA;      &#xA;      # fill in the gaps with LOCF&#xA;      resRow &lt;- r&#xA;      resRow[minStatusCol:maxStatusCol] &lt;- na.locf(r[minStatusCol:maxStatusCol])&#xA;      return(resRow)&#xA;    })&#xA;  # apply returns an array of dimension c(n, dim(X)[MARGIN]), hense need to transform:&#xA;  return(t(resPortfolio))&#xA;}&#xA;# 3. If a contract gets in a special rating (Default or Paid) &#xA;#    then leave it in that rating for the rest lifetime of the portfolio  &#xA;stuffPortfolioTerminateStates &lt;- function(portfolio){&#xA;  # if a loan encountered a D or P state &#xA;  # then force this state to be the terminate state for that loan&#xA;  &#xA;  firstEncounteredState &lt;- which(portfolio == 9 | portfolio == -1, arr.ind = TRUE) &#xA;  &#xA;  if (nrow(firstEncounteredState) > 0){&#xA;    firstEncounteredState &lt;- aggregate(firstEncounteredState[,'col'], by=list(firstEncounteredState[,'row']), FUN = min)&#xA;  } else { &#xA;  # if the portfolio doesn't have the special stages - make an empty data.frame so it won't affect the join below&#xA;    firstEncounteredState &lt;- data.frame(row = as.integer(NA), col = as.integer(NA))&#xA;  }&#xA;  names(firstEncounteredState) &lt;- c('row', 'colSpStateEncount')&#xA;  # add all other loans with colSpStateEncount = ncol(portfolio)&#xA;  firstEncounteredState &lt;- &#xA;    data.frame(row = 1:nrow(portfolio), colNum = ncol(portfolio)) %>% &#xA;    left_join(firstEncounteredState, by = 'row') %>%&#xA;    mutate(colSpStateEncount = dplyr::coalesce(colSpStateEncount, colNum)) %>%&#xA;    select(-colNum)&#xA;  &#xA;  maxColNum &lt;- ncol(portfolio)&#xA;  &#xA;  # once a loan entered a Default or Paid state, mark it as in this state in all later periods&#xA;  resPortfolio &lt;- &#xA;    mapply(FUN = function(row, colSpStateEncount, colNum){&#xA;      if(colSpStateEncount > colNum) stop('colSpStateEncount must be less colNum')&#xA;      res &lt;- portfolio[row, 1:colSpStateEncount]&#xA;      # if D or P, then stuff with the same state until max period o\w stuff with NAs (mean Incomplete)&#xA;      if(res[length(res)] %in% c(-1,9))&#xA;        res &lt;- c(res, rep(res[length(res)], colNum - colSpStateEncount)) # stuff tail with -1 or 9&#xA;      else &#xA;        res &lt;- c(res, rep(NA, colNum - colSpStateEncount)) # stuff tail with NAs&#xA;      return(res) &#xA;    }, firstEncounteredState$row, firstEncounteredState$colSpStateEncount, colNum = maxColNum, SIMPLIFY = F)&#xA;  resPortfolio &lt;- do.call(rbind, resPortfolio)&#xA;  return(resPortfolio)&#xA;}"/>
  </paragraphs>
</sse:LibraryNotebook>
