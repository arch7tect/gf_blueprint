<?xml version="1.0" encoding="ASCII"?>
<sse:LibraryNotebook xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:sse="http://www.neoflex.ru/meta/sse" name="FunctionLibrary" shortName="FunctionLibrary">
  <auditInfo changeUser="orlov" changeDateTime="2019-07-12T11:14:20.216+0300" createUser="admin" createDateTime="2019-06-21T14:08:59.784+0300"/>
  <paragraphs name="FunctionLibraryA_2019-06-21T14:09:45.548" textVisible="true" resultVisible="true" titleVisible="true">
    <body xsi:type="sse:CodeBody" interpreter="R" text="# &#xD;&#xA;# Functions for PD modeling with Weibull-Pareto model&#xD;&#xA;# vers. 3.1 /25 Jan 19/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;require(reshape2)&#xD;&#xA;require(data.table)&#xD;&#xA;require(lubridate)&#xD;&#xA;require(ggplot2)&#xD;&#xA;require(dplyr)&#xD;&#xA;require(tseries)&#xD;&#xA;require(zoo)&#xD;&#xA;require(forecast)&#xD;&#xA;require(matrixStats)&#xD;&#xA;require(survival)&#xD;&#xA;require(flexsurv)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;### ---- II. Functions for Analysis ----------------&#xD;&#xA;##### ---- 1. Data Transformation Functions --------&#xD;&#xA;&#xD;&#xA;MonthlyRollRates &lt;- function(data, initState, finalState, sectorLabels, legend = TRUE){&#xD;&#xA;  #&#xD;&#xA;  # returns monthly roll rates PD: iS-> fS withtin certain sectors&#xD;&#xA;  # finalState in a Default state&#xD;&#xA;  # sectorLabels might be a states vector&#xD;&#xA;  # &#xD;&#xA;  if (finalState &lt;= initState) {&#xD;&#xA;    stop(&quot;initState should be less finalState&quot;)&#xD;&#xA;  }&#xD;&#xA;  if (data[SectorLabel %in% sectorLabels, .N] == 0){&#xD;&#xA;    stop(paste(sectorLabels,&quot; contains no contracts&quot;))&#xD;&#xA;  }&#xD;&#xA;  periodSeq &lt;- data[SectorLabel %in% sectorLabels, NA, by = Period]&#xD;&#xA;&#xD;&#xA;  portfolioState &lt;- &#xD;&#xA;    data[SectorLabel %in% sectorLabels][&#xD;&#xA;      Rating == initState, .N, by = Period][&#xD;&#xA;      periodSeq, .(Period,  cnt = x.N), on = .(Period)][order(Period)]&#xD;&#xA;&#xD;&#xA;  transOverStatesNum &lt;- finalState - initState&#xD;&#xA;  portfolioTransit &lt;-&#xD;&#xA;    data[SectorLabel %in% sectorLabels][, &#xD;&#xA;      PeriodFrwd := shift(Rating, n = transOverStatesNum, type = 'lead'), by = loanid][&#xD;&#xA;      Rating == initState &amp; PeriodFrwd == finalState, .N, by = Period][&#xD;&#xA;      periodSeq, .(Period,  cnt = x.N), on = .(Period)][order(Period)]&#xD;&#xA;  portfolioTransit[, cnt := ifelse(is.na(cnt), 0, cnt)]&#xD;&#xA;  res.dt &lt;- &#xD;&#xA;    portfolioTransit[portfolioState, ':='(PD = x.cnt / ifelse(is.na(i.cnt), 1, i.cnt),&#xD;&#xA;                                          Universe = ifelse(is.na(i.cnt), 0, i.cnt)), &#xD;&#xA;                     on = .(Period)]&#xD;&#xA;&#xD;&#xA;  # shift rates from the period of Universe to the period when the default occurs&#xD;&#xA;  # currently Period is the period when Universe is calculated,&#xD;&#xA;  # we need Period be the period of default&#xD;&#xA;  res.dt[, ':='(cnt = shift(cnt, n = transOverStatesNum, type = 'lag'),&#xD;&#xA;                PD = shift(PD, n = transOverStatesNum, type = 'lag'),&#xD;&#xA;                Universe = shift(Universe, n = transOverStatesNum, type = 'lag'))]&#xD;&#xA;  if(legend){&#xD;&#xA;    res.dt[, ':='(rateType = paste0('PD',initState,'_',finalState),&#xD;&#xA;                  sector = paste(sectorLabels, collapse = ','))]&#xD;&#xA;  }&#xD;&#xA;  rm(periodSeq, portfolioState, portfolioTransit)&#xD;&#xA;  return(res.dt)&#xD;&#xA;} &#xD;&#xA;plotRollRates &lt;- function(sectorLabel, data, xbreaks = &quot;6 months&quot;,    #TODO: update these from &quot;MacroAdjustment.R&quot; -- Functions imported from Malta project&#xD;&#xA;                          addSmoothing = FALSE, span = 0.5, gg.aspect.ratio = NA){&#xD;&#xA;  plt &lt;- &#xD;&#xA;    ggplot(data[sector == sectorLabel],&#xD;&#xA;           aes(x = Period, y = PD * 100, color = rateType)) + &#xD;&#xA;    geom_line() +&#xD;&#xA;    scale_x_date(date_breaks = xbreaks, date_labels = &quot;%Y-%m&quot;) +&#xD;&#xA;    scale_color_manual(values = c('chartreuse4', 'firebrick','navy')) + &#xD;&#xA;    ylab(&quot;ODR, %&quot;) + xlab(paste(&quot;sector&quot;,sectorLabel)) + &#xD;&#xA;    facet_grid(rateType ~ ., scales = &quot;free&quot;) +&#xD;&#xA;    theme(axis.text.x = element_text(angle = 90, hjust = 1))&#xD;&#xA;  if(addSmoothing) &#xD;&#xA;    plt &lt;- plt + geom_smooth(span = span)&#xD;&#xA;  if(!is.na(gg.aspect.ratio))&#xD;&#xA;    plt &lt;- plt + theme(aspect.ratio = gg.aspect.ratio)&#xD;&#xA;  print(plt)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;exportCumulativePDs &lt;- function(data, fileName, CreditRiskScenario = &quot;&quot;, append = FALSE){&#xD;&#xA;  # export Cumulative PDs in long format (as in Fusion Risk)&#xD;&#xA;  if (!'periodNum' %in% colnames(data))&#xD;&#xA;    stop('data should contain period numbers and PDs in columns')&#xD;&#xA;  PDrefDict = c('PD0_9' = 'PD0_9', 'PD1_9' = 'PD1_9', 'PD2_9' = 'PD2_9','PD3_9' = 'PD3_9', 'PD4_9' = 'PD4_9')&#xD;&#xA;  result &lt;- melt(data, id.vars = 'periodNum', variable.factor = FALSE)&#xD;&#xA;  result[, ':='(sector = sapply(strsplit(variable, split = '[.]'), `[`, 1),&#xD;&#xA;                PDref = sapply(strsplit(variable, split = '[.]'), `[`, 2))]&#xD;&#xA;  write.table(result[order(sector, PDref, periodNum)][, &#xD;&#xA;                                                      .(CreditRiskScenario = CreditRiskScenario, &#xD;&#xA;                                                        PartySector = sector, &#xD;&#xA;                                                        PDReference = PDrefDict[PDref], &#xD;&#xA;                                                        ObservationDate = format(today(), '%d/%m/%Y'),&#xD;&#xA;                                                        RateMaturity = paste0(periodNum,'m'), &#xD;&#xA;                                                        HistoryValue = value * 100)], &#xD;&#xA;              sep = &quot;\t&quot;, dec = &quot;.&quot;,&#xD;&#xA;              file = fileName, quote = FALSE, row.names = FALSE, append = append, col.names = !append)&#xD;&#xA;}&#xD;&#xA;#TODO: exportCumulativePDsFusionRisk - export Cumulative PD in a fusion risk format&#xD;&#xA;&#xD;&#xA;##### ------- 2. Observed Default Rates (ODRs) Functions ------------&#xD;&#xA;&#xD;&#xA;# I. Clean up the portfolio matrix:&#xD;&#xA;# 1.Filter contracts and shift rations with a desired initial State (rating)&#xD;&#xA;initStatePortfolio &lt;- function(portfolio, initState, curInitState = 0){&#xD;&#xA;  require(matrixStats)&#xD;&#xA;  # makes a new porfolio which starts with an initState (rather than with state 1)&#xD;&#xA;&#xD;&#xA;  if (initState &lt; curInitState)&#xD;&#xA;    stop('initState must be more specific than curInitState')&#xD;&#xA;  &#xD;&#xA;  # select loans which had been in initState and get min period when it had gone there&#xD;&#xA;  initStatesInPort &lt;- which(portfolio == initState, arr.ind = TRUE) &#xD;&#xA;  # initStatesInPort is a matrix [row, col] with all initStates&#xD;&#xA;  # find the first period in initState by each loan (i.e. row):&#xD;&#xA;  if (nrow(initStatesInPort) > 0){&#xD;&#xA;    minInitStates &lt;- aggregate(initStatesInPort[,'col'], by=list(initStatesInPort[,'row']), FUN = min)&#xD;&#xA;  } else { &#xD;&#xA;    # not such initStates in the portfolio, return NA:&#xD;&#xA;    return(as.matrix(NA))&#xD;&#xA;  }&#xD;&#xA;  names(minInitStates) &lt;- c('row', 'colInitState')&#xD;&#xA;  maxColNum &lt;- ncol(portfolio)&#xD;&#xA;  &#xD;&#xA;  resPortfolio &lt;- &#xD;&#xA;    mapply(FUN = function(row, colInitState, colNum){&#xD;&#xA;      if(colInitState > colNum) stop('colInitState must be less colNum')&#xD;&#xA;      res &lt;- portfolio[row, colInitState:colNum]&#xD;&#xA;      res &lt;- c(res, rep(NA, colInitState - 1)) # stuff tail with NAs&#xD;&#xA;      return(res) &#xD;&#xA;    }, minInitStates$row, minInitStates$colInitState, colNum = maxColNum, SIMPLIFY = F)&#xD;&#xA;  resPortfolio &lt;- do.call(rbind, resPortfolio)&#xD;&#xA;  if(!is.matrix(resPortfolio)) { &#xD;&#xA;    # if one-contract on NULL portfolio is left&#xD;&#xA;    resPortfolio &lt;- matrix(resPortfolio, nrow = 1)&#xD;&#xA;  }&#xD;&#xA;  # drop columns with all NAs:&#xD;&#xA;  # calculate Num of NA, P, D in each column:&#xD;&#xA;  colStatusesCount &lt;- &#xD;&#xA;    colCounts(resPortfolio, value = NA, na.rm = F) +&#xD;&#xA;    colCounts(resPortfolio, value = -1, na.rm = T) +&#xD;&#xA;    colCounts(resPortfolio, value =  9, na.rm = T) &#xD;&#xA;&#xD;&#xA;  # just leave one extra column&#xD;&#xA;  maxRelevantColIdx &lt;- max(which(colStatusesCount &lt; nrow(resPortfolio)))&#xD;&#xA;  if(maxRelevantColIdx &lt; ncol(resPortfolio)) &#xD;&#xA;    maxRelevantColIdx &lt;- maxRelevantColIdx + 1&#xD;&#xA;  if(maxRelevantColIdx &lt; 1)  # corner case e.g. if all are in 9 (Default)&#xD;&#xA;    maxRelevantColIdx &lt;- 1&#xD;&#xA;  resPortfolio &lt;- resPortfolio[, 1:maxRelevantColIdx, drop = FALSE] &#xD;&#xA;  return(resPortfolio)&#xD;&#xA;}&#xD;&#xA;# 2. Fill in gaps in ratings between subsequent months &#xD;&#xA;#    with LOCF (Last Observation Carried Forward) &#xD;&#xA;fillInGaps &lt;- function(portfolio){&#xD;&#xA;  resPortfolio &lt;- &#xD;&#xA;    apply(portfolio, MARGIN = 1, FUN = function(r){&#xD;&#xA;      # take the range where Status available&#xD;&#xA;      if(length(which(!is.na(r))) == 0) {&#xD;&#xA;        return(r)&#xD;&#xA;      }&#xD;&#xA;      minStatusCol = min(which(!is.na(r)))&#xD;&#xA;      maxStatusCol = max(which(!is.na(r)))&#xD;&#xA;      &#xD;&#xA;      # fill in the gaps with LOCF&#xD;&#xA;      resRow &lt;- r&#xD;&#xA;      resRow[minStatusCol:maxStatusCol] &lt;- na.locf(r[minStatusCol:maxStatusCol])&#xD;&#xA;      return(resRow)&#xD;&#xA;    })&#xD;&#xA;  # apply returns an array of dimension c(n, dim(X)[MARGIN]), hense need to transform:&#xD;&#xA;  return(t(resPortfolio))&#xD;&#xA;}&#xD;&#xA;# 3. If a contract gets in a special rating (Default or Paid) &#xD;&#xA;#    then leave it in that rating for the rest lifetime of the portfolio  &#xD;&#xA;stuffPortfolioTerminateStates &lt;- function(portfolio){&#xD;&#xA;  # if a loan encountered a D or P state &#xD;&#xA;  # then force this state to be the terminate state for that loan&#xD;&#xA;  &#xD;&#xA;  firstEncounteredState &lt;- which(portfolio == 9 | portfolio == -1, arr.ind = TRUE) &#xD;&#xA;  &#xD;&#xA;  if (nrow(firstEncounteredState) > 0){&#xD;&#xA;    firstEncounteredState &lt;- aggregate(firstEncounteredState[,'col'], by=list(firstEncounteredState[,'row']), FUN = min)&#xD;&#xA;  } else { &#xD;&#xA;  # if the portfolio doesn't have the special stages - make an empty data.frame so it won't affect the join below&#xD;&#xA;    firstEncounteredState &lt;- data.frame(row = as.integer(NA), col = as.integer(NA))&#xD;&#xA;  }&#xD;&#xA;  names(firstEncounteredState) &lt;- c('row', 'colSpStateEncount')&#xD;&#xA;  # add all other loans with colSpStateEncount = ncol(portfolio)&#xD;&#xA;  firstEncounteredState &lt;- &#xD;&#xA;    data.frame(row = 1:nrow(portfolio), colNum = ncol(portfolio)) %>% &#xD;&#xA;    left_join(firstEncounteredState, by = 'row') %>%&#xD;&#xA;    mutate(colSpStateEncount = dplyr::coalesce(colSpStateEncount, colNum)) %>%&#xD;&#xA;    select(-colNum)&#xD;&#xA;  &#xD;&#xA;  maxColNum &lt;- ncol(portfolio)&#xD;&#xA;  &#xD;&#xA;  # once a loan entered a Default or Paid state, mark it as in this state in all later periods&#xD;&#xA;  resPortfolio &lt;- &#xD;&#xA;    mapply(FUN = function(row, colSpStateEncount, colNum){&#xD;&#xA;      if(colSpStateEncount > colNum) stop('colSpStateEncount must be less colNum')&#xD;&#xA;      res &lt;- portfolio[row, 1:colSpStateEncount]&#xD;&#xA;      # if D or P, then stuff with the same state until max period o\w stuff with NAs (mean Incomplete)&#xD;&#xA;      if(res[length(res)] %in% c(-1,9))&#xD;&#xA;        res &lt;- c(res, rep(res[length(res)], colNum - colSpStateEncount)) # stuff tail with -1 or 9&#xD;&#xA;      else &#xD;&#xA;        res &lt;- c(res, rep(NA, colNum - colSpStateEncount)) # stuff tail with NAs&#xD;&#xA;      return(res) &#xD;&#xA;    }, firstEncounteredState$row, firstEncounteredState$colSpStateEncount, colNum = maxColNum, SIMPLIFY = F)&#xD;&#xA;  resPortfolio &lt;- do.call(rbind, resPortfolio)&#xD;&#xA;  return(resPortfolio)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# II. Caculate ODRs (Observed Default Rates):&#xD;&#xA;# TODO: rewrite - see comments below&#xD;&#xA;getPortfolioParamsSeries &lt;- function(portfolio){&#xD;&#xA;  require(matrixStats)&#xD;&#xA;  require(dplyr)&#xD;&#xA;  # portfoio is a numeric matrix &#xD;&#xA;  # with periods in columns and loans in rows where &#xD;&#xA;  # -1 stands for Paid&#xD;&#xA;  #  9 stands for Default&#xD;&#xA;  &#xD;&#xA;  # return a list: Default, Paid, Universe series and number of Censored (still alive at the max time)&#xD;&#xA;  &#xD;&#xA;  # drop Defaults in the first period:&#xD;&#xA;  portfolio &lt;- portfolio[!portfolio[, 1] %in% c(-1, 9), ]  &#xD;&#xA;  &#xD;&#xA;  DefaultSeries &lt;- colSums2(portfolio == 9, na.rm = T) # colCounts(portfolio, value = 9, na.rm = T)&#xD;&#xA;  DefaultSeries &lt;- DefaultSeries - dplyr::lag(DefaultSeries) # sum entered in the Default state&#xD;&#xA;  DefaultSeries[1] = 0&#xD;&#xA;  PaidSeries &lt;- colSums2(portfolio == -1, na.rm = T)         # sum entered in the Paid state&#xD;&#xA;  PaidSeries &lt;- PaidSeries - dplyr::lag(PaidSeries)&#xD;&#xA;  PaidSeries[1] = 0&#xD;&#xA;  # Incomplete are those rows stuffed with NAs&#xD;&#xA;  # TODO: wrong! Incomplete are those rows which has not(NA) in the last column (at the last Reference Date)&#xD;&#xA;  # TODO: you should assign Paid contracts - those rows which has NAs from the last observable State through to the last Reference Date&#xD;&#xA;  # meaning it had got off-balance from the &#xD;&#xA;  # TODO: we also need to assign Paid for the SurvPortfolio to be formed in the right way, so write that part in prepPortfolioMatrix{}&#xD;&#xA;  # then here it won't be necessary to change anything&#xD;&#xA;  IncompleteSeries &lt;- colCounts(portfolio, value = NA, na.rm = F)&#xD;&#xA;  IncompleteSeries &lt;- IncompleteSeries - dplyr::lag(IncompleteSeries) # sum entered in the Incomlete state&#xD;&#xA;  IncompleteSeries[1] = 0&#xD;&#xA;  IncompleteNum &lt;- sum(!portfolio[, ncol(portfolio)] %in% c(-1, 9)) # num of Incomplete at the last period&#xD;&#xA;  &#xD;&#xA;  Universe &lt;- vector(mode = 'numeric', length = ncol(portfolio))&#xD;&#xA;  MarginalODR &lt;- vector(mode = 'numeric', length = ncol(portfolio) + 1) # extend ODRs for a last Incomplete period&#xD;&#xA;  Universe[1] &lt;- nrow(portfolio) #  sample size&#xD;&#xA;  for(t in 2:ncol(portfolio)){&#xD;&#xA;    Universe[t] &lt;- Universe[t-1] - DefaultSeries[t] - PaidSeries[t] - IncompleteSeries[t]&#xD;&#xA;  }&#xD;&#xA;  MarginalODR &lt;- DefaultSeries / (dplyr::lag(Universe) - IncompleteSeries) # the 1st will be NA because of lag&#xD;&#xA;  MarginalODR[1] &lt;- 0 &#xD;&#xA;  # decide how to use Incomplete exactly&#xD;&#xA;  return(list(Default = DefaultSeries,&#xD;&#xA;              Paid = PaidSeries,&#xD;&#xA;              Universe = Universe,&#xD;&#xA;              MarginalODR = MarginalODR,&#xD;&#xA;              Incomplete = IncompleteSeries)) &#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# III. Caculate ODRs for each Sector and store the results in a data.frame &#xD;&#xA;# Prepare a portfolio matrix for ODRs calculation:&#xD;&#xA;prepPortfolioMatrix &lt;- function(porfolioInputMatrix, sector,  &#xD;&#xA;                                originDateThres, ReferenceDateRange = c(min = NA, max = NA),&#xD;&#xA;                                DefState = 9, PaidState = -1){&#xD;&#xA;  #&#xD;&#xA;  # prepare a portfolio matrix in the format necessary to ODRs calculation&#xD;&#xA;  #&#xD;&#xA;  # porfolioInputMatrix - portfolio in the cast format (contracts in rows, monthly ratings in columns)&#xD;&#xA;  #                     - with columns &lt;loanid - contract id, originDate, SectorLabel - indicates a specific portfolio>&#xD;&#xA;  #                     - column names with the ratings must be in the date form &lt;yyyy-mm-dd>  &#xD;&#xA;  # sector = a character label of the portfolio for which ODRs are calculated&#xD;&#xA;  # originDateThres - only contracts with originDate > originDateThres are considered &#xD;&#xA;  # ReferenceDateRange a vector with min and max Reference Date used for calculation (if NA - use all the dates in porfolioInputMatrix)&#xD;&#xA;  # DefRating - the default rating in the portfolio matrix&#xD;&#xA;  # PaidState - the paid rating in the portfoio matrix&#xD;&#xA;  #&#xD;&#xA;  &#xD;&#xA;  &#xD;&#xA;  require(data.table)&#xD;&#xA;  require(dplyr)&#xD;&#xA;  require(lubridate)&#xD;&#xA;  &#xD;&#xA;  # ---- 1. Filtering porfolioInputMatrix: ----&#xD;&#xA;  metaColNames &lt;- c('loanid','originDate','SectorLabel') &#xD;&#xA;  if (!all(metaColNames %in% colnames(porfolioInputMatrix))) {&#xD;&#xA;    stop(&quot;&lt;loanid, originDate, SectorLabel> columns must be in porfolioInputMatrix&quot;)&#xD;&#xA;  }&#xD;&#xA;  &#xD;&#xA;  # filter columns by ReferenceDateRange:&#xD;&#xA;  RefDateCols &lt;- colnames(porfolioInputMatrix)[grep('[0-9]{4}-[0-9]{2}-[0-9]{2}', colnames(porfolioInputMatrix))]&#xD;&#xA;  RefDateCols_date &lt;- ymd(RefDateCols)&#xD;&#xA;  RefDateCols &lt;- RefDateCols[which(RefDateCols_date >= ifelse(!is.na(ReferenceDateRange['min']), &#xD;&#xA;                                                              ReferenceDateRange['min'], min(RefDateCols_date)) &amp;&#xD;&#xA;                                     RefDateCols_date &lt;= ifelse(!is.na(ReferenceDateRange['max']), &#xD;&#xA;                                                                ReferenceDateRange['max'], max(RefDateCols_date)) )]&#xD;&#xA;  if (length(RefDateCols) &lt; 2) {&#xD;&#xA;    stop(paste(&quot;Not enough Rating columns after filtering: &quot;, RefDateCols))&#xD;&#xA;  }&#xD;&#xA;  rm(RefDateCols_date)&#xD;&#xA;  # tmp:&#xD;&#xA;  # tryCatch( RefDateCols_date &lt;- ymd(RefDateCols),&#xD;&#xA;  #           warning = function(w) {print(&quot;Converting RefDateCols to date failed:&quot;)&#xD;&#xA;  #                                  print(ymd(RefDateCols)) })&#xD;&#xA;  &#xD;&#xA;  &#xD;&#xA;  # filter portfolio by sector\originDate:&#xD;&#xA;  resPortfolio &lt;- &#xD;&#xA;    porfolioInputMatrix %>%&#xD;&#xA;    filter(SectorLabel == sector) %>%&#xD;&#xA;    filter(originDate >= originDateThres) %>% &#xD;&#xA;    select(RefDateCols) %>% &#xD;&#xA;    as.matrix() &#xD;&#xA;  &#xD;&#xA;  # assign the Default and Paid states as 9 and -1:&#xD;&#xA;  resPortfolio &lt;-&#xD;&#xA;    structure(vapply(resPortfolio,  &#xD;&#xA;                     FUN = function(x) {&#xD;&#xA;                       if (is.na(x)) return(as.integer(NA))&#xD;&#xA;                       if (x == PaidState) return(-1L) # inner coding for Paid contracts&#xD;&#xA;                       if (x == DefState ) return(9L)    # inner coding for Default contracts&#xD;&#xA;                       return(as.integer(x))&#xD;&#xA;                     }, FUN.VALUE = integer(1)),&#xD;&#xA;              dim = dim(resPortfolio))&#xD;&#xA;  return(resPortfolio)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# TODO: move Filtering matrix to a separate function &lt;prepPortfolioMatrix> &#xD;&#xA;#       and use it here as an input &#xD;&#xA;#       we also need the same steps in getSuvivalPortfolio, so use it there as input as well&#xD;&#xA;getSectorPortlolioODRs &lt;- function(porfolio, sector, initStates, universeThres = 5, visualize = FALSE, accNumVisual = 10e2){&#xD;&#xA;  # &#xD;&#xA;  # Calculates ODRs according to Kaplan-Meyer estimator&#xD;&#xA;  #&#xD;&#xA;  # porfolio is a numeric matrix with stages for a portfolio (as prepared by prepPortfolioMatrix) &#xD;&#xA;  # initStates - &lt;int> vector of the initial impairment states for which ODRs are calculated (initState => Default)&#xD;&#xA;  # universeThres - the minimum number of contracts in Universe for which ODR is calculated, &#xD;&#xA;  #                 if less, consider this as not enough observations for a stable ODR and return NaN  &#xD;&#xA;  # sector - here is only for labeling in ODR data.table, need to be sure that porfolio is for that sector // TODO:  refactor&#xD;&#xA;  #&#xD;&#xA;  # returns a data.table with ODRs for the sector and all the initStates&#xD;&#xA;  #&#xD;&#xA;  &#xD;&#xA;  defaultState = 9L # a parameter for the default state (as it assigned in prepPortfolioMatrix)  &#xD;&#xA;  &#xD;&#xA;  # ---- 2. ODR calculations for each initState ----&#xD;&#xA;  ODRsSector &lt;- data.table(Period = integer(0), &#xD;&#xA;                 Universe = integer(0),&#xD;&#xA;                 Incomplete = integer(0),&#xD;&#xA;                 Paid = integer(0),&#xD;&#xA;                 Default = integer(0),&#xD;&#xA;                 PD = numeric(0),&#xD;&#xA;                 rateType = character(0),&#xD;&#xA;                 sector = character(0))&#xD;&#xA;  &#xD;&#xA;  for (s in initStates){&#xD;&#xA;    # PD s => Default:&#xD;&#xA;    sPortfolio_PrtParam &lt;- &#xD;&#xA;      porfolio %>%&#xD;&#xA;      initStatePortfolio(initState = s, curInitState = 0) %>%   &#xD;&#xA;      fillInGaps() %>% &#xD;&#xA;      stuffPortfolioTerminateStates() %>% &#xD;&#xA;      getPortfolioParamsSeries() # TODO: throw an error if &lt; 2 rows are left here&#xD;&#xA;    &#xD;&#xA;    sODRs &lt;- &#xD;&#xA;      data.table(Period = 1:length(sPortfolio_PrtParam$MarginalODR), # TODO: change periods to start from 0 ?&#xD;&#xA;                 Universe = sPortfolio_PrtParam$Universe,&#xD;&#xA;                 Incomplete = sPortfolio_PrtParam$Incomplete, &#xD;&#xA;                 Paid = sPortfolio_PrtParam$Paid,&#xD;&#xA;                 Default = sPortfolio_PrtParam$Default,&#xD;&#xA;                 PD = sPortfolio_PrtParam$MarginalODR,&#xD;&#xA;                 rateType = paste0('PD',s,'_',defaultState),&#xD;&#xA;                 sector = sector)&#xD;&#xA;    ODRsSector &lt;- rbindlist(list(ODRsSector, sODRs))&#xD;&#xA;    &#xD;&#xA;    # ---- heatmap a random 1000 from the portfolio -----&#xD;&#xA;    if (visualize){&#xD;&#xA;    sPortfolioMatrix &lt;- &#xD;&#xA;      porfolio %>%&#xD;&#xA;      initStatePortfolio(initState = s, curInitState = 0) %>% &#xD;&#xA;      fillInGaps() %>% &#xD;&#xA;      stuffPortfolioTerminateStates() %>%&#xD;&#xA;      `[`(i = sample.int(n = nrow(.), size = min(accNumVisual, nrow(.))), j = )&#xD;&#xA;    # Visualize whole portfolio&#xD;&#xA;    # heatmap(sPortfolioMatrix,&#xD;&#xA;    #         distfun = function(x) {dist(x, method = &quot;manhattan&quot;)},&#xD;&#xA;    #         Rowv = NULL, Colv = NA, scale = 'none',&#xD;&#xA;    #         col = brewer.pal(7, &quot;OrRd&quot;)&#xD;&#xA;    # )&#xD;&#xA;    # order manually by sum of states&#xD;&#xA;    heatmap(sPortfolioMatrix[order(rowSums2(coalesce(sPortfolioMatrix, 0L))), ],&#xD;&#xA;            distfun = function(x) {dist(x, method = &quot;manhattan&quot;)},&#xD;&#xA;            Rowv = NA, Colv = NA, scale = 'none',&#xD;&#xA;            col = brewer.pal(7, &quot;OrRd&quot;)&#xD;&#xA;    )&#xD;&#xA;    title(paste0(sector, ': PD',s,'_',defaultState)) }&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  # set a threshold on the Universe for Kaplan-Meyer estimation &#xD;&#xA;  # (if the denominator for ODR &lt; threshold, consider it as not enough stats for estimation)&#xD;&#xA;  ODRsSector[lag(Universe,1) - Incomplete &lt; universeThres, PD := NaN]&#xD;&#xA;  return(ODRsSector)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# IV. Get Survival Objects from the ODRs&#xD;&#xA;getSuvivalPortfolio &lt;- function(portfolio){&#xD;&#xA;  # transform portfolio matrix into a dataset: (time, status) for each loan &#xD;&#xA;  # returns a survival object with Surv{survival}&#xD;&#xA;  # apply(samplePortfolioNumeric[1:5,], FUN = max, MARGIN = 1)&#xD;&#xA;  MaxPeriod &lt;- ncol(portfolio)&#xD;&#xA;  DefautTime &lt;- apply(portfolio, FUN = function(x){&#xD;&#xA;    which.max(x == 9) # takes period when ecountered the first 9 o\w 1&#xD;&#xA;  }, MARGIN = 1) &#xD;&#xA;  PaidTime &lt;- apply(portfolio, FUN = function(x){&#xD;&#xA;    which.max(x == -1) # takes period when ecountered the first 9 o\w 1&#xD;&#xA;  }, MARGIN = 1)&#xD;&#xA;  &#xD;&#xA;  #TODO supply D and P status directly rather than max, min (9 and -1)&#xD;&#xA;  &#xD;&#xA;  # Drop 1 state, NA means it's in non-Default or non-Paid state&#xD;&#xA;  DefautTime[which(DefautTime == 1)] &lt;- NA # replace(a, a == 1, NA)&#xD;&#xA;  PaidTime[which(PaidTime == 1)] &lt;- NA&#xD;&#xA;  LifeTime &lt;- pmin(DefautTime, PaidTime, na.rm = TRUE) # life of the credit is whatever happened earlier - D or P &#xD;&#xA;  AliveTime &lt;- rep(0, length(LifeTime))&#xD;&#xA;  AliveTime[!is.na(DefautTime)] &lt;- 1 # considered Dead at the Default period only (Paid and active are Alive)    &#xD;&#xA;  &#xD;&#xA;  # not all credits are alive until MaxPeriod&#xD;&#xA;  # get max periods for alive loans:&#xD;&#xA;  MaxPeriods &lt;- apply(portfolio, FUN = function(x){&#xD;&#xA;    which.max(is.na(x)) - 1 # takes period when ecountered the first NA o\w 1 (subtract 1 to get the last active period)&#xD;&#xA;  }, MARGIN = 1) &#xD;&#xA;  # set MaxPeriod to those returned 0 (assume can't be NA in the first period)&#xD;&#xA;  #TODO: (!) wrong! - the MaxPeriod is the max for all of the contract, but for a particulat contract it depends of its start date &#xD;&#xA;  MaxPeriods[which(MaxPeriods == 0)] &lt;- MaxPeriod &#xD;&#xA;  LifeTime[is.na(LifeTime)] &lt;- MaxPeriods[is.na(LifeTime)] &#xD;&#xA;  # LifeTime[is.na(LifeTime)] &lt;- MaxPeriod  # for the Active credits set the Life time to the max period&#xD;&#xA;  &#xD;&#xA;  &#xD;&#xA;  &#xD;&#xA;  return(list(DefaultPeriod = DefautTime,&#xD;&#xA;              PaidPeriod = PaidTime,&#xD;&#xA;              LifePeriod = LifeTime,&#xD;&#xA;              AliveIndex = AliveTime))&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;getSurvObject &lt;- function(PortfolioSurv){&#xD;&#xA;  # returns a Survival object from list PortfolioSurv&#xD;&#xA;  require(survival)&#xD;&#xA;  return(Surv(time = PortfolioSurv$LifePeriod, event = PortfolioSurv$AliveIndex))&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;getSurvObjectsPortfolio &lt;- function(porfolio, sector, initStates, visualize = FALSE){&#xD;&#xA;  # &#xD;&#xA;  # The Survival Objects from the portfolio matrix for each Initial State&#xD;&#xA;  #&#xD;&#xA;  # porfolio is a numeric matrix with stages for a portfolio (as prepared by prepPortfolioMatrix) &#xD;&#xA;  # initStates - &lt;int> vector of the initial impairment states for which ODRs are calculated (initState => Default)&#xD;&#xA;  # sector - here is only for labeling in ODR data.table, need to be sure that porfolio is for that sector // TODO:  refactor&#xD;&#xA;  # if visualize - plot a nonparametric Kaplan-Meyer estimator for each initState&#xD;&#xA;  # &#xD;&#xA;  # returns a list of survival objects for the sector and all the initStates&#xD;&#xA;  #&#xD;&#xA;  require(survival)&#xD;&#xA;  require(survminer)&#xD;&#xA;  defaultState = 9L # a parameter for the default state (as it assigned in prepPortfolioMatrix)  &#xD;&#xA;  &#xD;&#xA;  SurvSector &lt;- vector(&quot;list&quot;, length(initStates))&#xD;&#xA;  SurvSectorNames &lt;- NULL&#xD;&#xA;  &#xD;&#xA;  # TODO: consider instead of geeting a SurvObject with getSurvObject&#xD;&#xA;  #       use a data.table for all the impairmnet stages&#xD;&#xA;  #       them all those could be fitted with survfit(Surv(time, censor) ~ strata(initState))&#xD;&#xA;  #       and for W-P fit getSurvObject could be called later - before fitting&#xD;&#xA;  # TODO: fit the W-P hazards to the K_M survival curves, visualize&#xD;&#xA;  &#xD;&#xA;  for (s in initStates){&#xD;&#xA;    # PD s => Default:&#xD;&#xA;    sPortfolio_Surv &lt;- &#xD;&#xA;      porfolio %>%&#xD;&#xA;      initStatePortfolio(initState = s, curInitState = 0) %>% &#xD;&#xA;      fillInGaps() %>% &#xD;&#xA;      stuffPortfolioTerminateStates() %>% &#xD;&#xA;      getSuvivalPortfolio() %>%&#xD;&#xA;      getSurvObject()&#xD;&#xA;    &#xD;&#xA;    SurvSector[[which(initStates == s)]] &lt;- sPortfolio_Surv&#xD;&#xA;    SurvSectorNames &lt;- c(SurvSectorNames, paste0('.PD',s,'_',defaultState))&#xD;&#xA;  }&#xD;&#xA;  &#xD;&#xA;  # ---- Kaplan-Meyer estimator plot -----&#xD;&#xA;  if (visualize){&#xD;&#xA;    # combine the SurvObjects fit in a list for visualization with {survminer}&#xD;&#xA;    SurvSectorFit &lt;- vector(&quot;list&quot;, length(initStates))&#xD;&#xA;    # str(SurvSector)&#xD;&#xA;    for(i in 1:length(SurvSector)){&#xD;&#xA;      SurvSectorFit[[i]] &lt;- survfit(SurvSector[[i]] ~ 1)&#xD;&#xA;    }&#xD;&#xA;    names(SurvSectorFit) &lt;- SurvSectorNames&#xD;&#xA;    g &lt;- ggsurvplot_combine(fit = SurvSectorFit, fun = &quot;pct&quot;) +&#xD;&#xA;      ggtitle(paste('Portfolio:',sector))&#xD;&#xA;    print(g)&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  names(SurvSector) &lt;- paste0(sector, SurvSectorNames)&#xD;&#xA;  return(SurvSector)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;##### ------ 3. Analysis Functions ----------------&#xD;&#xA;# ------ a. Weibull-Pareto parametrization --------&#xD;&#xA;WeibullParetoHazard &lt;- function(t, t0, beta, k, log = FALSE){&#xD;&#xA;  # gives the h(t) as it's parametrised in the BAI paper&#xD;&#xA;  # add log for {flexsurv} definition&#xD;&#xA;  if(t&lt;0){&#xD;&#xA;    if (!log) return(0) &#xD;&#xA;    else return(log(0))&#xD;&#xA;  }&#xD;&#xA;  u = beta / k&#xD;&#xA;  alpha = 1 + u&#xD;&#xA;  A = u / (u + exp(-alpha))&#xD;&#xA;  B = (1 + u) / (1 + u * exp(alpha))&#xD;&#xA;  theta = ifelse(t > t0, 0, 1)&#xD;&#xA;  if (!log){&#xD;&#xA;    Wpart = (A * k * alpha / t0) * (t/t0)^(k-1) * exp(-alpha * (t/t0)^k) / (1 - A + A*exp(-alpha * (t/t0)^k))&#xD;&#xA;    Ppart = beta / t&#xD;&#xA;  } else {&#xD;&#xA;    # check t because for log(x), x > 0&#xD;&#xA;    Wpart = ifelse(t &lt;= t0, log(A * k * alpha / t0) + (k-1) * log(t/t0) - alpha * (t/t0)^k - log(1 - A + A*exp(-alpha * (t/t0)^k)), NA)&#xD;&#xA;    Ppart = ifelse(t > t0, log(beta) -  log(t), NA)&#xD;&#xA;  }&#xD;&#xA;  # res &lt;- Wpart * theta + Ppart * (1 - theta)&#xD;&#xA;  res &lt;- ifelse(t &lt;= t0, Wpart, Ppart)&#xD;&#xA;  names(res) &lt;- NULL&#xD;&#xA;  return(res)&#xD;&#xA;}&#xD;&#xA;WeibullParetoCumHazard &lt;- function(t, t0, beta, k){&#xD;&#xA;  # gives the H(t) as it's parametrised in the BAI paper&#xD;&#xA;  # # H(t) = -log[1-A+Ae(-alpha (t/t0)^k)] theta + beta log(t) - beta log(t0) + log(B)&#xD;&#xA;  # (?) what to do with log(B)? it's not there when integrating h(u), but it is when take -log(S(t))&#xD;&#xA;  # >> include log(B), see the grathic - it should be smooth&#xD;&#xA;  if(t&lt;0) return(0)&#xD;&#xA;  u = beta / k&#xD;&#xA;  alpha = 1 + u&#xD;&#xA;  A = u / (u + exp(-alpha))&#xD;&#xA;  B = (1 + u) / (1 + u * exp(alpha))&#xD;&#xA;  theta = ifelse(t > t0, 0, 1)&#xD;&#xA;  # check t because for log(x), x > 0&#xD;&#xA;  Wpart = ifelse(t &lt;= t0, -log(1 - A + A * exp(-alpha * (t/t0)^k)), NA)&#xD;&#xA;  Ppart = ifelse(t > t0, beta * log(t) - beta * log(t0) - log(B), NA)&#xD;&#xA;  # res &lt;- Wpart * theta + Ppart * (1 - theta)&#xD;&#xA;  res &lt;- ifelse(t &lt;= t0, Wpart, Ppart)&#xD;&#xA;  names(res) &lt;- NULL&#xD;&#xA;  return(res)&#xD;&#xA;}&#xD;&#xA;WeibullParetoHazard &lt;- Vectorize(WeibullParetoHazard, vectorize.args = c('t'))&#xD;&#xA;WeibullParetoCumHazard &lt;- Vectorize(WeibullParetoCumHazard, vectorize.args = c('t'))&#xD;&#xA;# TODO write explicitly pdf and cdf of WeibullPareto for flexsurvreg cos there's some glitch with the hazards&#xD;&#xA;WeibullParetoCDF &lt;- function(t, t0, beta, k, log = FALSE){&#xD;&#xA;  # gives the F(t) as it's parametrised in the BAI paper&#xD;&#xA;  # add log for {flexsurv} definition&#xD;&#xA;  if(t&lt;0){&#xD;&#xA;    if (!log) return(0) &#xD;&#xA;    else return(log(0))&#xD;&#xA;  }&#xD;&#xA;  u = beta / k&#xD;&#xA;  alpha = 1 + u&#xD;&#xA;  A = u / (u + exp(-alpha))&#xD;&#xA;  B = (1 + u) / (1 + u * exp(alpha))&#xD;&#xA;  theta = ifelse(t > t0, 0, 1)&#xD;&#xA;  if (!log){&#xD;&#xA;    Wpart = A * (1 - exp(-alpha * (t/t0)^k))&#xD;&#xA;    Ppart = (1 - B * (t0/t)^beta)&#xD;&#xA;  } else {&#xD;&#xA;    # check t because for log(x), x > 0&#xD;&#xA;    Wpart = ifelse(t &lt;= t0, log(A) + log(1 - exp(-alpha * (t/t0)^k)), NA)&#xD;&#xA;    Ppart = ifelse(t > t0, log(1 - B * (t0/t)^beta), NA) # evaluates as NaN when t &lt; t0, in that case shouldn't be evaluated at all &#xD;&#xA;  }&#xD;&#xA;  # res &lt;- Wpart * theta + Ppart * (1 - theta)&#xD;&#xA;  res &lt;- ifelse(t &lt;= t0, Wpart, Ppart)&#xD;&#xA;  names(res) &lt;- NULL&#xD;&#xA;  return(res)&#xD;&#xA;}&#xD;&#xA;WeibullParetoPDF &lt;- function(t, t0, beta, k, log = FALSE){&#xD;&#xA;  # gives the f(t) as it's parametrised in the BAI paper&#xD;&#xA;  # add log for {flexsurv} definition&#xD;&#xA;  if(t&lt;0){&#xD;&#xA;    if (!log) return(0) &#xD;&#xA;    else return(log(0))&#xD;&#xA;  }&#xD;&#xA;  u = beta / k&#xD;&#xA;  alpha = 1 + u&#xD;&#xA;  A = u / (u + exp(-alpha))&#xD;&#xA;  B = (1 + u) / (1 + u * exp(alpha))&#xD;&#xA;  theta = ifelse(t > t0, 0, 1)&#xD;&#xA;  if (!log){&#xD;&#xA;    Wpart = (A * k * alpha / t0) * (t/t0)^(k-1) * exp(-alpha * (t/t0)^k) &#xD;&#xA;    Ppart = (B * beta / t0) * (t/t0)^(-beta-1)&#xD;&#xA;  } else {&#xD;&#xA;    # check t because for log(x), x > 0&#xD;&#xA;    Wpart = ifelse(t &lt;= t0, log(A * k * alpha / t0) + (k-1) * log(t/t0) - alpha * (t/t0)^k, NA)&#xD;&#xA;    Ppart = ifelse(t > t0, log(B) + log(beta) - log(t0) - (beta + 1)*(log(t) - log(t0)), NA)&#xD;&#xA;  }&#xD;&#xA;  # res &lt;- Wpart * theta + Ppart * (1 - theta)&#xD;&#xA;  res &lt;- ifelse(t &lt;= t0, Wpart, Ppart)&#xD;&#xA;  names(res) &lt;- NULL&#xD;&#xA;  return(res)&#xD;&#xA;}&#xD;&#xA;WeibullParetoCDF &lt;- Vectorize(WeibullParetoCDF, vectorize.args = c('t'))&#xD;&#xA;WeibullParetoPDF &lt;- Vectorize(WeibullParetoPDF, vectorize.args = c('t'))&#xD;&#xA;&#xD;&#xA;# ------  b. Weibull-Pareto parametrization for flexsurv --------&#xD;&#xA;# Define Weibull-Pareto hazard functions &#xD;&#xA;hWeibullPareto &lt;- function(t, t0, beta, k, log = FALSE) {&#xD;&#xA;  WeibullParetoHazard(t, t0, beta, k, log = log)&#xD;&#xA;}&#xD;&#xA;HWeibullPareto &lt;- function(t, t0, beta, k, log = FALSE) { &#xD;&#xA;  if(!log)&#xD;&#xA;    WeibullParetoCumHazard(t, t0, beta, k)&#xD;&#xA;  else&#xD;&#xA;    log(WeibullParetoCumHazard(t, t0, beta, k))&#xD;&#xA;}&#xD;&#xA;# Define Weibull-Pareto pdf,cdf functions &#xD;&#xA;dWeibullPareto &lt;- function(x, t0, beta, k, log = FALSE) {&#xD;&#xA;  WeibullParetoPDF(t = x, t0, beta, k, log = log)&#xD;&#xA;}&#xD;&#xA;pWeibullPareto &lt;- function(q, t0, beta, k, log = FALSE) { &#xD;&#xA;  WeibullParetoCDF(t = q, t0, beta, k, log = log)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;qWeibullPareto &lt;- function(p, ...) {&#xD;&#xA;  # cat('qWeibullPareto paramlist: ',..., '\n')&#xD;&#xA;  flexsurv::qgeneric(pWeibullPareto, p, matargs = c('t0', 'beta', 'k'), ...)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# tmp - plot with ggplot as usual&#xD;&#xA;plotWeibullParetoHazard &lt;- function(optpar, from, to, MarginalODR, title = '', ylim = NA){&#xD;&#xA;  curve(WeibullParetoHazard(x, &#xD;&#xA;                            t0 = optpar['t0'], &#xD;&#xA;                            beta = optpar['beta'], &#xD;&#xA;                            k = optpar['k']), &#xD;&#xA;        from = from, to = to, xlab=&quot;t&quot;, ylab=&quot;h(t)&quot;, col = 'firebrick',&#xD;&#xA;        ylim = c(0, ifelse(is.na(ylim), max(MarginalODR, na.rm = T)*1.05, ylim) ))&#xD;&#xA;  lines(MarginalODR, type = 'l', col = 'navy')&#xD;&#xA;  title(title)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# t0 > 0, beta > 0, k > 1 // use transforms to map on (-Inf, +Inf)&#xD;&#xA;WeibullParetoDist &lt;- list(name = &quot;WeibullPareto&quot;,&#xD;&#xA;                          pars = c(&quot;t0&quot;,&quot;beta&quot;,&quot;k&quot;), location = &quot;k&quot;,&#xD;&#xA;                          transforms = c(log, log, function(x) log(x - 1)),    &#xD;&#xA;                          inv.transforms = c(exp, exp, function(x) 1 + exp(x)),&#xD;&#xA;                          inits = function(t){ c(median(t), 1.2 , 5.5) } &#xD;&#xA;                          # TODO get init for t0 as median(t|non censored) ?&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;# ------  c. Pareto parametrization for flexsurv --------&#xD;&#xA;# Needed when the max hazard is in the 1st period (e.g. PD4_9)&#xD;&#xA;# use the W-P functions with only Pareto part&#xD;&#xA;# Define Pareto hazard functions &#xD;&#xA;# dpareto &lt;- function(x, m, s, log = FALSE){&#xD;&#xA;#   rmutil::dpareto(y = x, m, s, log)&#xD;&#xA;# }&#xD;&#xA;# rm(dpareto)&#xD;&#xA;hPareto &lt;- function(t, beta, k, log = FALSE) {&#xD;&#xA;  WeibullParetoHazard(t, t0 = 1, beta, k, log = log)&#xD;&#xA;}&#xD;&#xA;HPareto &lt;- function(t, beta, k, log = FALSE) { &#xD;&#xA;  if(!log)&#xD;&#xA;    WeibullParetoCumHazard(t, t0 = 1, beta, k)&#xD;&#xA;  else&#xD;&#xA;    log(WeibullParetoCumHazard(t, t0 = 1, beta, k))&#xD;&#xA;}&#xD;&#xA;ParetoDist &lt;- list(name = &quot;Pareto&quot;,&#xD;&#xA;                          pars = c(&quot;beta&quot;, &quot;k&quot;), location = &quot;k&quot;,&#xD;&#xA;                          transforms = c(log, function(x) log(x - 1)),    &#xD;&#xA;                          inv.transforms = c(exp, function(x) 1 + exp(x)),&#xD;&#xA;                          inits = function(t){ c(1,2) } &#xD;&#xA;                          # TODO get init for t0 as median(t|non censored) ?&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# ------ Fit PD curves to ODR ------------------&#xD;&#xA;WeibullParetoFit &lt;- function(SurvObject, initialParams, timeHorizon, dist = WeibullParetoDist, methodOpt = &quot;BFGS&quot;, verbose = TRUE,&#xD;&#xA;                             returnParams = FALSE){&#xD;&#xA;  # fit Weibull-Pareto dutribution to the ODRs in the form of Survival Object&#xD;&#xA;  # using optimization in flexsurv package&#xD;&#xA;  # timeHorizon is a range to which we get the fitted curve&#xD;&#xA;  require(flexsurv)&#xD;&#xA;  # fit optimization&#xD;&#xA;  fitPortfolioSurvWeibullPareto &lt;- &#xD;&#xA;    flexsurvreg(SurvObject ~ 1,&#xD;&#xA;                inits = initialParams,&#xD;&#xA;                dist = dist,&#xD;&#xA;                method = methodOpt,&#xD;&#xA;                control = list(trace = 2, REPORT = ifelse(verbose, 1, 0)))&#xD;&#xA;  if(verbose)&#xD;&#xA;    print(fitPortfolioSurvWeibullPareto)&#xD;&#xA;  &#xD;&#xA;  # get the distribution with the timeHorizon&#xD;&#xA;  optpar &lt;- fitPortfolioSurvWeibullPareto$res[,1]&#xD;&#xA;  # TODO: shortcut - add t0 for Pareto tail&#xD;&#xA;  if(!'t0' %in% names(optpar)) optpar['t0'] &lt;- 1&#xD;&#xA;  series.fit &lt;- &#xD;&#xA;    WeibullParetoHazard(timeHorizon, &#xD;&#xA;                        t0 = optpar['t0'], &#xD;&#xA;                        beta = optpar['beta'], &#xD;&#xA;                        k = optpar['k'])&#xD;&#xA;  if (returnParams){&#xD;&#xA;    return(optpar)&#xD;&#xA;  } else {&#xD;&#xA;    return(series.fit)&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;loessFit &lt;- function(dataSeries, span, replaceNegative = TRUE, &#xD;&#xA;                     removeInitGap = TRUE, predict.extrapolate = 0){&#xD;&#xA;  # no NAs are assumed in dataSeries except in the beginning due to &#xD;&#xA;  # the shift in roll rates to the period of the default&#xD;&#xA;  # e.g. PD1_4 begins at the 3rd period, while PD3_4 begins at the 1st&#xD;&#xA;  # with removeInitGap = TRUE we place 0 at the beginnig of the fit&#xD;&#xA;  # since for e.g. PD1_4 there can't be default in period 2 under our assumtions&#xD;&#xA;&#xD;&#xA;  if(removeInitGap){&#xD;&#xA;   dataSeries[is.na(dataSeries)] &lt;- 0&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  series.loess &lt;- loess(dataSeries ~ seq_along(dataSeries), &#xD;&#xA;                        family = &quot;gaussian&quot;, span = span, na.action = &quot;na.exclude&quot;,&#xD;&#xA;                        control = loess.control(surface = &quot;interpolate&quot;))&#xD;&#xA;  if (predict.extrapolate > 0){&#xD;&#xA;    series.fit &lt;- predict(series.loess, &#xD;&#xA;                          newdata = seq_along(c(dataSeries, 1:predict.extrapolate))) &#xD;&#xA;  } else {&#xD;&#xA;    series.fit &lt;- predict(series.loess)&#xD;&#xA;  }&#xD;&#xA;  if(replaceNegative){&#xD;&#xA;    series.fit[series.fit &lt; 0] &lt;- 0&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  return(series.fit)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# ------ Merton-Vasicek correction functions -----------------&#xD;&#xA;getMeanRollRates &lt;- function(data, sectorLabels){&#xD;&#xA;  # calculate mean roll rates by sector and rate type&#xD;&#xA;  data[sector %in% sectorLabels, &#xD;&#xA;            .(meanPD = mean(PD, na.rm = TRUE), &#xD;&#xA;              meanUniverse = mean(Universe, na.rm = TRUE)),&#xD;&#xA;            by = .(sector, rateType)][order(sector, rateType)]&#xD;&#xA;}&#xD;&#xA;getBaselCorWithinSector &lt;- function(meanPD, sectorType, verbose = FALSE){&#xD;&#xA;  # calculate Basel Correlations of PD within each sector &#xD;&#xA;  # according to the sectorType &#xD;&#xA;  # sectorType must be 'retail', 'corporate', ...&#xD;&#xA;  # formuli see in Basel:&#xD;&#xA;  # - corporate in par.272&#xD;&#xA;  # - retail in par.330&#xD;&#xA;  if(!sectorType %in% c('retail', 'corporate')) {&#xD;&#xA;    stop('sectorType must be \'retail\' or \'corporate\'')&#xD;&#xA;  }&#xD;&#xA;  # Basel coef dictionary&#xD;&#xA;  BaselCoefDict &lt;- data.frame(sectorType = c('retail', 'corporate'),&#xD;&#xA;                                    expW = c(-35, -50),&#xD;&#xA;                                      w1 = c(0.03, 0.12),&#xD;&#xA;                                      w2 = c(0.16, 0.24))&#xD;&#xA;  row.names(BaselCoefDict) &lt;- BaselCoefDict[, 'sectorType']&#xD;&#xA;  # sectorType expW   w1   w2&#xD;&#xA;  #     retail   35   0.03 0.16&#xD;&#xA;  #  corporate   50   0.12 0.24&#xD;&#xA;  if(verbose) {&#xD;&#xA;    cat('sectorType =', sectorType, '| expW =', BaselCoefDict[sectorType, 'expW'],&#xD;&#xA;        '| w1 =', BaselCoefDict[sectorType, 'w1'], '| w2 =', BaselCoefDict[sectorType, 'w2'], '\n')&#xD;&#xA;  }&#xD;&#xA;  expTerm = (1-exp(BaselCoefDict[sectorType, 'expW'] * meanPD)) / (1-exp(BaselCoefDict[sectorType, 'expW']))&#xD;&#xA;  return(BaselCoefDict[sectorType, 'w1'] * expTerm + &#xD;&#xA;         BaselCoefDict[sectorType, 'w2'] * (1 - expTerm))&#xD;&#xA;}  &#xD;&#xA;# vectorise getBaselCorWithinSectorm to apply it on data.table&#xD;&#xA;getBaselCorWithinSector &lt;- Vectorize(FUN = getBaselCorWithinSector)&#xD;&#xA;&#xD;&#xA;MertonVasicekPDadjustment &lt;- function(PD, rho, y){&#xD;&#xA;  # adjust predicted PD on macro indices (forecasted) through Merton-Vasicek model&#xD;&#xA;  # it's wrong as it adjusts to within-sector correlation (according to Basel -y = F^-1(q = 0.999))&#xD;&#xA;  # to get marco adjustment we need something else&#xD;&#xA;  # see Analysis of the IRB asset correlation coefficient(Merton model simple).pdf p.15 (11)&#xD;&#xA;  &#xD;&#xA;  pnorm( (qnorm(PD) - sqrt(rho)*y) / sqrt(1 - rho) )&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;RollRatesLoessMVadjustment &lt;- function(sector, rateType, data, CorRisk, riskFactor){&#xD;&#xA;  # takes a column from RollRatesLoess and correct it&#xD;&#xA;  # according to Merton-Vasicek model:&#xD;&#xA;  #  - proportion of systematic risk rho is the correlation taken from CorRisk table &#xD;&#xA;  #  - CorRisk is a data.table which contains sector, rateType and Cor with the correlation (we put meanRollRates here)&#xD;&#xA;  #  - external risk factor y is supplied as riskFactor&#xD;&#xA;  #    length of riskFactor must correspond to the length of RollRatesLoess&#xD;&#xA;  &#xD;&#xA;  if(data[extraPeriods == FALSE, .N] != length(riskFactor)) {&#xD;&#xA;    stop('length of riskFactor must correspond to the length of data')&#xD;&#xA;  }&#xD;&#xA;  data.col &lt;- paste0(sector,'.',rateType) &#xD;&#xA;  ratesLoess &lt;- data[extraPeriods == FALSE, .SD, .SDcols = data.col][[1]]&#xD;&#xA;  p_sector &lt;- sector # params to avoid data.table scope conflict&#xD;&#xA;  p_rateType &lt;- rateType&#xD;&#xA;  corSystemRisk &lt;- CorRisk[sector == p_sector &amp; rateType == p_rateType, Cor]&#xD;&#xA;  riskFactor &lt;- as.numeric(riskFactor) # in case it was provided as ts&#xD;&#xA;  return(MertonVasicekPDadjustment(PD = ratesLoess,&#xD;&#xA;                                   rho = corSystemRisk,&#xD;&#xA;                                   y = riskFactor))&#xD;&#xA;}&#xD;&#xA;plotAdjustedPD &lt;- function(sectors, rateTypes, rates, ratesAdjusted, &#xD;&#xA;                           scales = &quot;fixed&quot;, gg.aspect.ratio = NA){&#xD;&#xA;  # nice ggplots of rated and adjusted rates &#xD;&#xA;  # for each (sector, rateType) from paramsin rows &#xD;&#xA;  if(rates[, .N] != ratesAdjusted[,.N]){ # TODO: think about:: extraPeriods == FALSE&#xD;&#xA;    stop(&quot;length of the datasets must be equal&quot;)&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  # get col names in data in the form: sector.rateType&#xD;&#xA;  curveNames &lt;- lapply(sectors, FUN = function(x) paste0(x,'.', rateTypes))&#xD;&#xA;  # check if all rates are in the data&#xD;&#xA;  for(curveName in unlist(curveNames)){&#xD;&#xA;    if(!curveName %in% colnames(rates)) &#xD;&#xA;      stop(paste(curveName, &quot;not found in rates&quot;))&#xD;&#xA;    if(!curveName %in% colnames(ratesAdjusted)) &#xD;&#xA;      stop(paste(curveName, &quot;not found in ratesAdjusted&quot;))&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  for(i in 1:length(curveNames)){&#xD;&#xA;    plt &lt;- &#xD;&#xA;    ggplot(data = melt(ratesAdjusted, &#xD;&#xA;                       id.vars = &quot;periodNum&quot;, measure.vars = curveNames[[i]])[!is.na(value)]) + &#xD;&#xA;      geom_line(data = melt(rates[extraPeriods == FALSE],&#xD;&#xA;                            id.vars = &quot;periodNum&quot;, measure.vars = curveNames[[i]])[!is.na(value)],&#xD;&#xA;                aes(x = periodNum, y = value), color = 'navy') +&#xD;&#xA;      geom_line(aes(x = periodNum, y = value), color = 'firebrick') +&#xD;&#xA;      geom_area(aes(x = periodNum, y = value), fill = 'skyblue4', alpha = 0.3) +&#xD;&#xA;      ylab('Marginal PD') + xlab('Month') +&#xD;&#xA;      facet_wrap(~variable, scales = scales)&#xD;&#xA;    if(!is.na(gg.aspect.ratio)) {&#xD;&#xA;      plt &lt;- plt + theme(aspect.ratio = gg.aspect.ratio)&#xD;&#xA;    }&#xD;&#xA;    print(plt)&#xD;&#xA;  }&#xD;&#xA;} &#xD;&#xA;&#xD;&#xA;# ------ Cumulative PD functions -----------------&#xD;&#xA;getCumulativePD &lt;- function(PDcurve){&#xD;&#xA;  # when PD is NA, e.g. in the first period, treat it as 0 - it won't change the cumulative curve&#xD;&#xA;  PDcurve[is.na(PDcurve)] &lt;- 0 &#xD;&#xA;  return(1 - cumprod(1 - PDcurve))&#xD;&#xA;}&#xD;&#xA;getMarginalPD &lt;- function(CumPDcurve){&#xD;&#xA;  # a reverse to getCumulativePD()&#xD;&#xA;  # resPD &lt;- vector(mode = 'numerical', length(CumPDcurve)) &#xD;&#xA;  resPD &lt;- 1 - (1 - CumPDcurve) / (1 - lag(CumPDcurve, 1)) &#xD;&#xA;  resPD[1] &lt;- CumPDcurve[1]&#xD;&#xA;  return(resPD)&#xD;&#xA;}&#xD;&#xA;plotCumulativePD &lt;- function(sectors, rateTypes, data, gg.aspect.ratio = NA){&#xD;&#xA;  # get col names in data in the form: sector.rateType&#xD;&#xA;  curveNames &lt;- lapply(sectors, FUN = function(x) paste0(x,'.', rateTypes))&#xD;&#xA;  nRateTypes &lt;- length(rateTypes)&#xD;&#xA;  colorRates &lt;- RColorBrewer::brewer.pal(nRateTypes, 'Dark2')&#xD;&#xA;  # check if all rates are in the data&#xD;&#xA;  for(curveName in unlist(curveNames)){&#xD;&#xA;    if(!curveName %in% colnames(data)) &#xD;&#xA;      stop(paste(curveName, &quot;not found in data&quot;))&#xD;&#xA;  }&#xD;&#xA;  for(i in 1:length(curveNames)){&#xD;&#xA;    plt &lt;- &#xD;&#xA;      ggplot(data = melt(data, &#xD;&#xA;                         id.vars = &quot;periodNum&quot;, measure.vars = curveNames[[i]])[!is.na(value)]) + &#xD;&#xA;      geom_line(aes(x = periodNum, y = value, color = variable)) + &#xD;&#xA;      scale_color_manual(values = colorRates) + &#xD;&#xA;      labs(x = 'Period', y = 'Cumulative PD') + &#xD;&#xA;      ggtitle(paste('Portfolio:',curveNames[[i]]))&#xD;&#xA;      # facet_wrap(~variable, scales = scales)&#xD;&#xA;    if(!is.na(gg.aspect.ratio)) {&#xD;&#xA;      plt &lt;- plt + theme(aspect.ratio = gg.aspect.ratio)&#xD;&#xA;    }&#xD;&#xA;    print(plt)&#xD;&#xA;  } &#xD;&#xA;}&#xD;&#xA;plotCumulativePDcomparison &lt;- function(sectors, rateTypes, data, dataComp, gg.aspect.ratio = NA){&#xD;&#xA;  # get col names in data in the form: sector.rateType&#xD;&#xA;  curveNames &lt;- lapply(sectors, FUN = function(x) paste0(x,'.', rateTypes))&#xD;&#xA;  nRateTypes &lt;- length(rateTypes)&#xD;&#xA;  colorRates &lt;- RColorBrewer::brewer.pal(nRateTypes, 'Dark2')&#xD;&#xA;  # check if all rates are in the data&#xD;&#xA;  for(curveName in unlist(curveNames)){&#xD;&#xA;    if(!curveName %in% colnames(data)) &#xD;&#xA;      stop(paste(curveName, &quot;not found in data&quot;))&#xD;&#xA;  }&#xD;&#xA;  for(i in 1:length(curveNames)){&#xD;&#xA;    plt &lt;- &#xD;&#xA;      ggplot() + &#xD;&#xA;      geom_line(data = melt(data, &#xD;&#xA;                            id.vars = &quot;periodNum&quot;, measure.vars = curveNames[[i]])[!is.na(value)],&#xD;&#xA;                aes(x = periodNum, y = value, color = variable)) +&#xD;&#xA;      geom_line(data = melt(dataComp, &#xD;&#xA;                            id.vars = &quot;periodNum&quot;, measure.vars = curveNames[[i]])[!is.na(value)],&#xD;&#xA;                aes(x = periodNum, y = value, color = variable), linetype = 'dashed') +&#xD;&#xA;      scale_color_manual(values = colorRates) + &#xD;&#xA;      geom_hline(yintercept = 0) + # temporal, drop&#xD;&#xA;      labs(x = 'Period', y = 'Cumulative PD') + &#xD;&#xA;      ggtitle(paste('Curves comparison: Portfolio:', str_sub(curveNames[[i]], end = str_length(curveNames[[i]]) - 6)))&#xD;&#xA;    # facet_wrap(~variable, scales = scales)&#xD;&#xA;    if(!is.na(gg.aspect.ratio)) {&#xD;&#xA;      plt &lt;- plt + theme(aspect.ratio = gg.aspect.ratio)&#xD;&#xA;    }&#xD;&#xA;    print(plt)&#xD;&#xA;  } &#xD;&#xA;}&#xD;&#xA;CDFrestrict &lt;- function(dataSeries){&#xD;&#xA;  # apply restrictions on c.d.f.: &#xD;&#xA;  # - betweeen [0,1]&#xD;&#xA;  # - increasing&#xD;&#xA;  dataSeries[dataSeries &lt; 0] &lt;- 0&#xD;&#xA;  dataSeries[dataSeries > 1] &lt;- 1&#xD;&#xA;  return(cummax(dataSeries))&#xD;&#xA;}&#xD;&#xA;PDFrestrict &lt;- function(dataSeries){&#xD;&#xA;  # apply restrictions on p.d.f.: &#xD;&#xA;  # > 0&#xD;&#xA;  dataSeries[dataSeries &lt; 0] &lt;- 0&#xD;&#xA;  dataSeries[dataSeries > 1] &lt;- 0.99&#xD;&#xA;  return(dataSeries)&#xD;&#xA;}&#xD;&#xA;"/>
  </paragraphs>
</sse:LibraryNotebook>
